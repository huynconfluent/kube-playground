#!/bin/sh

# Usage:
#   ./start.sh
#
# or
#
#   CFK_HELM_VERSION=2.11.1 ./start.sh
#   CFK_IMAGE_VERSION=0.1193.34 ./start.sh
#   CFK_HELM_VERSION=2.11.1 ./start.sh -m

BASE_DIR=$(pwd)
REQUIRED_PKG="docker k3d kubectl helm yq jq"
# defaults
CLUSTER_TYPE="k3d"
DEPLOY_CFK=true
DEPLOY_LDAP=false
DEPLOY_IDP=false
DEPLOY_HASHICORPVAULT=false
DEPLOY_FLINK=false
DEPLOY_CMF=false
NO_INFRA=false
AUTOGEN_ASSETS=false
FIPS_ENABLED=false
#
set -o allexport; source .env; set +o allexport

# check for prerequisites
for PKG in $REQUIRED_PKG; do
    if [ -z "$(which ${PKG})" ]; then
        printf "REQUIRED: %s" "${PKG}"
        printf "\nPlease install %s" "${PKG}"
        printf "\nUsing Brew:"
        printf "\n\tbrew install %s" "${PKG}"
        exit 1
    fi
done

# for macOS specifically check for docker-mac-net-connect
if [ "$(uname)" == "Darwin" ]; then
    if [ -z "$(which docker-mac-net-connect)" ]; then
        printf "REQUIRED: docker-mac-net-connect"
        printf "\nPlease install docker-mac-net-connect"
        printf "\nUsing Brew:"
        printf "\n\tbrew install chipmk/tap/docker-mac-net-connect"
        exit 1
    fi
fi

# flags
usage () {
    printf "Usage: $0 [-m] [-e] [comma separated array] [-f] [-s] [-z] [-i] [-a]\n"
    printf "\t-m                                    (optional) deploy k3d on multipass vm instead of local k3d\n"
    printf "\t-e [ldap,idp,vault,flink]             (optional) deploy extras, comma seperated string array\n"
    printf "\t-f                                    (optional) deploys CFK in FIPS mode\n"
    printf "\t-s                                    (optional) skip infrastructre deployment (no k3d, multipass, metallb, etc)\n"
    printf "\t-z                                    (optional) skip cfk deployment\n"
    printf "\t-i                                    (optional) deploy interactively\n"
    printf "\t-a                                    (optional) deploy with autogenerated assets (e.g. ssl, creds, etc)\n"
    printf "\t-h                                    help menu\n"
    exit 1
}

while getopts "me:siazf" opt; do
    case $opt in
        m)
            CLUSTER_TYPE="multipass"
            ;;
        e)
            # external authstore
            EXT_AUTH_ARRAY=( ${OPTARG//,/ } )

            for i in "${EXT_AUTH_ARRAY[@]}"; do
                case "$i" in
                    "ldap")
                        DEPLOY_LDAP=true
                        ;;
                    "idp")
                        DEPLOY_IDP=true
                        ;;
                    "vault")
                        DEPLOY_HASHICORPVAULT=true
                        ;;
                    "flink")
                        DEPLOY_FLINK=true
                        ;;
                    *)
                        printf "-e Argument not recognized...\n"
                        usage
                        ;;
                esac
            done
            ;;
        f)
            # enable FIPs mode
            FIPS_ENABLED=true
            ;;
        s)
            # No Infrastructure deployment
            NO_INFRA=true 
            ;;
        a)
            AUTOGEN_ASSETS=true
            ;;
        i)
            # Interactive deployment
            printf "Interactive Menu NOT YET implemented\n"
            ;;
        z)
            # skip cfk deployment
            DEPLOY_CFK=false
            ;;
        *)
            usage
            ;;
    esac
done

# clear flags
shift $((OPTIND -1))

# starting kube playground
#printf "\n======== Kube Playground =========\n\n"
source $BASE_DIR/scripts/system/header.sh -t "Kube Playground"

create_multipass_cluster () {

    #printf "Deploying with Multipass VM instead of local K3d...\n"
    # call deploy-multipass vm
    source $BASE_DIR/scripts/helper/deploy-multipass.sh
}

create_kube_cluster () {

    k3d_config="$BASE_DIR/configs/k3d/default.yaml"

    printf "\n"
    printf "Checking for k3d version...\n"
    k3d version || exit 1
    printf "\n"

    # check if cluster is already running or not
    if [ $(k3d cluster list | grep -c "${K3D_CLUSTER_NAME}") -ne 0 ]; then
        printf "K3d Cluster is already running, skipping deployment....\n"
    else
        printf "Creating K3D Cluster.......\n"
        if [ -f "$k3d_config" ]; then
            k3d cluster create --config $k3d_config --wait
        else
            printf "\nCould not find %s so cannot create k3d cluster, exiting....\n" "$k3d_config"
            exit 1
        fi
    fi

    # add artifical delay? It's taking 5+ minutes on this arm mac. I think the extra time is because of slow container download. Taking like a minute
    source $BASE_DIR/scripts/system/header.sh -t "Checking CoreDNS is running..."
    #printf "\n\n=========Is CoreDNS up?==========\n"

    # wait for coreDNS to be ready
    timeout=$OVERALL_TIMEOUT
    sleep_in_seconds=5
    while [ "$(kubectl -n kube-system get deployment coredns | grep -c '1/1')" -lt 1 ]; do
        if [ $timeout -le 0 ]; then
            printf "\nTimed out waiting on CoreDNS, %s seconds\n" "$timeout"
            exit 1
        fi
        printf "\nWaiting for CoreDNS to be ready..."
        sleep $sleep_in_seconds
        timeout=$((timeout-sleep_in_seconds))
    done
    
    printf "\n"
}

deploy_metallb () {

    source $BASE_DIR/scripts/helper/deploy-metallb.sh

    # Call docker-mac-net-connect checker
    if [ "$CLUSTER_TYPE" == "k3d" ] && [ "$(uname)" == "Darwin" ]; then
        source "$BASE_DIR/scripts/helper/check-docker-net.sh"
    fi

}

check_cfk_version () {

    cfk_version_mapping="$BASE_DIR/configs/cfk/version_mapping.json"
    
    if [ ! -z "$CFK_HELM_VERSION" ]; then
        CFK_IMAGE_VERSION=$(jq -r 'to_entries[] | select(.key == '\"$CFK_HELM_VERSION\"') | .value' $cfk_version_mapping)
        if [ -z "$CFK_IMAGE_VERSION" ]; then
            printf "\nCFK_HELM_VERSION=%s is not valid version, exiting....\n" "$CFK_HELM_VERSION"
            exit 1
        fi
    fi

    if [ ! -z "$CFK_IMAGE_VERSION" ]; then
        CFK_HELM_VERSION=$(jq -r 'to_entries[] | select(.value == '\"$CFK_IMAGE_VERSION\"') | .key' $cfk_version_mapping)
        if [ -z "$CFK_HELM_VERSION" ]; then
            printf "\nCFK_IMAGE_VERSION=%s is not a valid version, exiting....\n" "$CFK_IMAGE_VERSION"
        fi
    fi
}

#######################DEPLOY INFRASTRUCTURE###################################
# decide the type of kubernetes cluster to create
# TODO: add options for terraform and openshift

printf "\nCluster Infrastructure Type: %s\n\n" "$CLUSTER_TYPE"

if [ "$NO_INFRA" == "false" ]; then
    case "$CLUSTER_TYPE" in
        "multipass")
            create_multipass_cluster
            ;;
        "k3d")
            create_kube_cluster
            ;;
        *)
            printf "Cluster Type not recognized: %s\n" "$CLUSTER_TYPE"
            exit 1
        ;;
    esac

    # Deploy MetalLB
    deploy_metallb
fi

############################DEPLOY ASSETS######################################
# Deploy autogenerated SSL
if [ "$AUTOGEN_ASSETS" == "true" ]; then
    source $BASE_DIR/scripts/helper/deploy-ssl.sh
fi

# Deploy autogenerated credentials
# TODO: This ^

#######################DEPLOY CLUSTERS/APPS####################################
# Call deploy-ldap
if [ "$DEPLOY_LDAP" == "true" ]; then
    source $BASE_DIR/scripts/helper/deploy-ldap.sh
else
    printf "\nSkipping LDAP Deployment....\n"
fi

# Call deploy-idp
if [ "$DEPLOY_IDP" == "true" ]; then
    source $BASE_DIR/scripts/helper/deploy-idp.sh
else
    printf "\nSkipping Keycloak Deployment....\n"
fi

# Call deploy-hashicorp-vault
if [ "$DEPLOY_HASHICORPVAULT" == "true" ]; then
    source $BASE_DIR/scripts/helper/deploy-hashicorp-vault.sh
fi

# check if we are setting a CFK Helm Version or Image Version
source $BASE_DIR/scripts/system/header.sh -t "Deploying CFK"
#printf "\n=Determine CFK Version to Deploy=\n"
check_cfk_version

# Call deploy_cfk
if [ "$DEPLOY_CFK" == "true" ]; then
    deploy_cfk_cmd="$BASE_DIR/scripts/helper/deploy-cfk.sh"

    if [ ! -z "$CFK_IMAGE_VERSION" ]; then
        #source $BASE_DIR/scripts/helper/deploy-cfk.sh -v "$CFK_IMAGE_VERSION"
        deploy_cfk_cmd+=" -v $CFK_IMAGE_VERSION"
    fi

    if [ "$FIPS_ENABLED" == true ]; then
        deploy_cfk_cmd+=" -f"
    fi

    source $deploy_cfk_cmd
else
    printf "\nCFK not needed, Skipping CFK Deployment....\n"
fi

# deploy flink
if [ "$DEPLOY_FLINK" == "true" ]; then
    # Call deploy cert-manager
    source $BASE_DIR/scripts/helper/deploy-cert-manager.sh -v "$CERT_MANAGER_VERSION"
    # Call cp-flink
    source $BASE_DIR/scripts/helper/deploy-flink-operator.sh -v "1.130.2" -w "confluent,flink"
    # Call deploy-cmf
    source $BASE_DIR/scripts/helper/deploy-cmf.sh -v "$CMF_VERSION" -n "confluent"
fi

# DONE!
source $BASE_DIR/scripts/system/header.sh -t "Kube Playground is now ready!"
#printf "\n\nKube Playground is now ready!\n"
# TODO: display a helper info?
